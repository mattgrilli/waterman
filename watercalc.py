#!/usr/bin/env python3
"""
Aetheric Water Optimizer - GUI Version

A graphical interface for finding the best combination of 3 aetheric waters 
that average closest to 7 (or custom target).
"""

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog, filedialog
import json
import os
import re
from itertools import combinations
from typing import List, Tuple, Dict, Optional

class AethericWaterManager:
    def __init__(self, data_file='aetheric_waters.json'):
        self.data_file = data_file
        self.waters = []
        self.used_waters = []
        self.load_data()
    
    def load_data(self):
        """Load water data from JSON file, or create new if doesn't exist"""
        if os.path.exists(self.data_file):
            with open(self.data_file, 'r') as f:
                data = json.load(f)
                self.waters = data.get('available', [])
                self.used_waters = data.get('used', [])
    
    def save_data(self):
        """Save current state to JSON file"""
        data = {
            'available': self.waters,
            'used': self.used_waters
        }
        with open(self.data_file, 'w') as f:
            json.dump(data, f, indent=2)
    
    def add_waters(self, water_values: List[float]):
        """Add new aetheric waters to the available pool"""
        for value in water_values:
            self.waters.append({'value': value, 'id': len(self.waters) + len(self.used_waters)})
        self.save_data()
    
    def find_best_combination(self, target: float = 7.0) -> Tuple[Optional[List[Dict]], Optional[float]]:
        """Find the combination of 3 waters that averages closest to target"""
        if len(self.waters) < 3:
            return None, None
        
        best_combination = None
        best_avg = None
        best_diff = float('inf')
        
        for combo in combinations(self.waters, 3):
            avg = sum(w['value'] for w in combo) / 3
            diff = abs(avg - target)
            
            if diff < best_diff:
                best_diff = diff
                best_avg = avg
                best_combination = list(combo)
        
        return best_combination, best_avg
    
    def use_combination(self, combination: List[Dict]):
        """Mark a combination as used and remove from available pool"""
        if combination is None:
            return

        for water in combination:
            if water in self.waters:
                self.waters.remove(water)
                self.used_waters.append(water)

        self.save_data()

    def restore_water(self, water: Dict):
        """Move a water from used back to available"""
        if water in self.used_waters:
            self.used_waters.remove(water)
            self.waters.append(water)
            self.save_data()

    def delete_water(self, water: Dict, from_used: bool = True):
        """Permanently delete a water from either used or available"""
        if from_used and water in self.used_waters:
            self.used_waters.remove(water)
            self.save_data()
        elif not from_used and water in self.waters:
            self.waters.remove(water)
            self.save_data()

    def generate_picker_script(self, combination: List[Dict]) -> str:
        """Generate Razor picker script with the specified water values"""
        if not combination or len(combination) != 3:
            return ""

        # Extract the three values
        val1, val2, val3 = [w['value'] for w in combination]

        script = f'''#############################################
# Aetheric Water Picker ‚Äì Outlands / Razor
#
# Auto-generated by Aetheric Water Optimizer
# These are the optimal 3 waters to average closest to target
#############################################

@setvar! need1 1
@setvar! need2 1
@setvar! need3 1

overhead "Aetheric picker: scanning backpack for essences..." 88

@clearignore
getlabel backpack pingcheck

# Loop through all Aetheric Water (ID 3902) in backpack
while findtype 3902 backpack as ess
    getlabel ess desc

    # VALUE 1
    if need1 = 1 and "aetheric water: {val1:.3f} aP" in desc
        overhead "Grabbing vial 1 now" 88
        lift ess
        drop backpack -1 -1 -1
        wait 650
        @setvar! need1 0

    # VALUE 2
    elseif need2 = 1 and "aetheric water: {val2:.3f} aP" in desc
        overhead "Grabbing vial 2 now" 88
        lift ess
        drop backpack -1 -1 -1
        wait 650
        @setvar! need2 0

    # VALUE 3
    elseif need3 = 1 and "aetheric water: {val3:.3f} aP" in desc
        overhead "Grabbing vial 3 now" 88
        lift ess
        drop backpack -1 -1 -1
        wait 650
        @setvar! need3 0
    endif

    @ignore ess

    # Stop once we've found all three
    if need1 = 0 and need2 = 0 and need3 = 0
        break
    endif
endwhile

@clearignore

if need1 = 0 and need2 = 0 and need3 = 0
    overhead "All 3 requested essences moved to your backpack." 68
    sysmsg "All 3 requested essences moved to your backpack." 68
else
    overhead "Finished scanning ‚Äì some values were not found." 34
    sysmsg "Finished scanning ‚Äì some values were not found." 34
endif
'''
        return script

    def generate_scanner_script(self) -> str:
        """Generate Razor scanner script for scanning all aetheric waters"""
        script = '''#############################################
# Aetheric Water Scanner ‚Äì Outlands / Razor
#
# HOW TO USE:
#  1. Put all Aetheric Water items in your backpack
#  2. Run this script
#  3. Check your journal/system messages for the output
#  4. Copy the output to import into the Python GUI
#
# This script scans all aetheric waters in your
# backpack and displays their values in the journal.
#############################################

overhead "Scanning all aetheric waters in backpack..." 88

@clearignore
getlabel backpack pingcheck

@setvar! count 0

# Loop through all Aetheric Water (ID 3902) in backpack
while findtype 3902 backpack as ess
    getlabel ess desc

    # Display the full label
    sysmsg "{{desc}}" 88

    @ignore ess
    @setvar! count count + 1
    wait 100
endwhile

@clearignore

overhead "Scan complete! Found {{count}} aetheric waters." 68
sysmsg "Scan complete! Found {{count}} aetheric waters." 68
sysmsg "Copy the values above and import into Python GUI" 68
'''
        return script

    def import_from_text(self, text: str) -> List[float]:
        """Parse aetheric water values from text (e.g., journal export or manual entry)"""
        values = []
        # Match pattern for Razor journal format:
        # "[Razor]: aetheric water: 8.811 aP (expires in 1d 23h 2m) [bound to...]"
        # Also matches simpler format: "aetheric water: 8.820 aP"
        pattern = r'aetheric water:\s*([\d.]+)\s*aP'

        for line in text.split('\n'):
            match = re.search(pattern, line, re.IGNORECASE)
            if match:
                try:
                    value = float(match.group(1))
                    values.append(value)
                except ValueError:
                    continue

        # Deduplicate while preserving order
        seen = set()
        unique_values = []
        for value in values:
            if value not in seen:
                seen.add(value)
                unique_values.append(value)

        return unique_values


class AethericWaterGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Aetheric Water Optimizer")
        self.root.geometry("800x600")
        self.root.resizable(True, True)
        
        self.manager = AethericWaterManager()
        self.current_combo = None
        self.current_avg = None
        
        # Configure style
        self.style = ttk.Style()
        self.style.theme_use('clam')
        
        # Color scheme - fantasy/magical theme
        self.bg_color = "#2c1810"
        self.fg_color = "#e8d4b0"
        self.accent_color = "#8b6914"
        self.highlight_color = "#d4af37"
        
        self.root.configure(bg=self.bg_color)
        
        self.setup_ui()
        self.refresh_display()
    
    def setup_ui(self):
        """Setup the user interface"""
        # Main container
        main_frame = tk.Frame(self.root, bg=self.bg_color)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Title and options bar
        title_frame = tk.Frame(main_frame, bg=self.bg_color)
        title_frame.pack(fill=tk.X, pady=(0, 10))

        title_label = tk.Label(
            title_frame,
            text="‚öóÔ∏è Aetheric Water Optimizer ‚öóÔ∏è",
            font=("Georgia", 20, "bold"),
            bg=self.bg_color,
            fg=self.highlight_color
        )
        title_label.pack(side=tk.LEFT, expand=True)

        # Stay on top checkbox
        self.stay_on_top_var = tk.BooleanVar(value=False)
        stay_on_top_cb = tk.Checkbutton(
            title_frame,
            text="üìå Stay on Top",
            variable=self.stay_on_top_var,
            command=self.toggle_stay_on_top,
            bg=self.bg_color,
            fg=self.fg_color,
            selectcolor=self.bg_color,
            activebackground=self.bg_color,
            activeforeground=self.highlight_color,
            font=("Arial", 9),
            cursor="hand2"
        )
        stay_on_top_cb.pack(side=tk.RIGHT, padx=(0, 10))
        
        # Top section - Controls
        control_frame = tk.Frame(main_frame, bg=self.bg_color)
        control_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Add waters section
        add_frame = tk.LabelFrame(
            control_frame,
            text="Add New Waters",
            font=("Georgia", 11, "bold"),
            bg=self.bg_color,
            fg=self.fg_color,
            relief=tk.RIDGE,
            bd=2
        )
        add_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        
        tk.Label(
            add_frame,
            text="Enter values (comma-separated):",
            bg=self.bg_color,
            fg=self.fg_color,
            font=("Arial", 9)
        ).pack(anchor=tk.W, padx=5, pady=(5, 0))
        
        self.add_entry = tk.Entry(add_frame, font=("Arial", 10), width=30)
        self.add_entry.pack(padx=5, pady=5, fill=tk.X)
        self.add_entry.bind('<Return>', lambda e: self.add_waters())
        
        button_frame = tk.Frame(add_frame, bg=self.bg_color)
        button_frame.pack(padx=5, pady=(0, 5), fill=tk.X)

        tk.Button(
            button_frame,
            text="‚ûï Add Waters",
            command=self.add_waters,
            bg=self.accent_color,
            fg="white",
            font=("Arial", 9, "bold"),
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        ).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 2))

        tk.Button(
            button_frame,
            text="üìÇ Import",
            command=self.import_from_file,
            bg=self.accent_color,
            fg="white",
            font=("Arial", 9, "bold"),
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        ).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=2)

        tk.Button(
            button_frame,
            text="üì§ Export Scanner",
            command=self.export_scanner_script,
            bg="#2c5f6e",
            fg="white",
            font=("Arial", 9, "bold"),
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        ).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(2, 0))
        
        # Find combination section
        find_frame = tk.LabelFrame(
            control_frame,
            text="Find Best Combination",
            font=("Georgia", 11, "bold"),
            bg=self.bg_color,
            fg=self.fg_color,
            relief=tk.RIDGE,
            bd=2
        )
        find_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5, 0))
        
        tk.Label(
            find_frame,
            text="Target average:",
            bg=self.bg_color,
            fg=self.fg_color,
            font=("Arial", 9)
        ).pack(anchor=tk.W, padx=5, pady=(5, 0))
        
        target_entry_frame = tk.Frame(find_frame, bg=self.bg_color)
        target_entry_frame.pack(padx=5, pady=5, fill=tk.X)
        
        self.target_entry = tk.Entry(target_entry_frame, font=("Arial", 10), width=10)
        self.target_entry.insert(0, "7.0")
        self.target_entry.pack(side=tk.LEFT, padx=(0, 5))
        
        tk.Button(
            target_entry_frame,
            text="üîç Find Best",
            command=self.find_combination,
            bg=self.accent_color,
            fg="white",
            font=("Arial", 10, "bold"),
            cursor="hand2",
            relief=tk.RAISED,
            bd=2
        ).pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        # Button frame for Use and Export
        use_button_frame = tk.Frame(find_frame, bg=self.bg_color)
        use_button_frame.pack(padx=5, pady=(0, 5), fill=tk.X)

        self.export_button = tk.Button(
            use_button_frame,
            text="üìù Export Script",
            command=self.export_script,
            bg="#6b5416",
            fg="white",
            font=("Arial", 9, "bold"),
            cursor="hand2",
            relief=tk.RAISED,
            bd=2,
            state=tk.DISABLED
        )
        self.export_button.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 2))

        self.use_button = tk.Button(
            use_button_frame,
            text="‚úì Use Combination",
            command=self.use_combination,
            bg="#2d5016",
            fg="white",
            font=("Arial", 9, "bold"),
            cursor="hand2",
            relief=tk.RAISED,
            bd=2,
            state=tk.DISABLED
        )
        self.use_button.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(2, 0))
        
        # Middle section - Results
        result_frame = tk.LabelFrame(
            main_frame,
            text="Best Combination Found",
            font=("Georgia", 12, "bold"),
            bg=self.bg_color,
            fg=self.highlight_color,
            relief=tk.RIDGE,
            bd=3
        )
        result_frame.pack(fill=tk.BOTH, pady=(0, 10))
        
        self.result_text = tk.Text(
            result_frame,
            height=6,
            font=("Courier New", 11),
            bg="#3d2817",
            fg=self.highlight_color,
            relief=tk.SUNKEN,
            bd=2,
            state=tk.DISABLED
        )
        self.result_text.pack(padx=5, pady=5, fill=tk.BOTH, expand=True)
        
        # Bottom section - Lists
        lists_frame = tk.Frame(main_frame, bg=self.bg_color)
        lists_frame.pack(fill=tk.BOTH, expand=True)
        
        # Available waters
        available_frame = tk.LabelFrame(
            lists_frame,
            text="Available Waters",
            font=("Georgia", 11, "bold"),
            bg=self.bg_color,
            fg=self.fg_color,
            relief=tk.RIDGE,
            bd=2
        )
        available_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        
        self.available_listbox = tk.Listbox(
            available_frame,
            font=("Courier New", 9),
            bg="#3d2817",
            fg=self.fg_color,
            selectmode=tk.SINGLE,
            relief=tk.SUNKEN,
            bd=2
        )
        self.available_listbox.pack(padx=5, pady=5, fill=tk.BOTH, expand=True)

        available_scroll = tk.Scrollbar(self.available_listbox)
        available_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        self.available_listbox.config(yscrollcommand=available_scroll.set)
        available_scroll.config(command=self.available_listbox.yview)

        # Context menu for available waters
        self.available_menu = tk.Menu(self.root, tearoff=0, bg=self.bg_color, fg=self.fg_color)
        self.available_menu.add_command(label="Delete", command=self.delete_available_water)
        self.available_listbox.bind("<Button-3>", self.show_available_menu)
        
        # Used waters
        used_frame = tk.LabelFrame(
            lists_frame,
            text="Used Waters",
            font=("Georgia", 11, "bold"),
            bg=self.bg_color,
            fg=self.fg_color,
            relief=tk.RIDGE,
            bd=2
        )
        used_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(5, 0))
        
        self.used_listbox = tk.Listbox(
            used_frame,
            font=("Courier New", 9),
            bg="#3d2817",
            fg="#888",
            selectmode=tk.SINGLE,
            relief=tk.SUNKEN,
            bd=2
        )
        self.used_listbox.pack(padx=5, pady=5, fill=tk.BOTH, expand=True)

        used_scroll = tk.Scrollbar(self.used_listbox)
        used_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        self.used_listbox.config(yscrollcommand=used_scroll.set)
        used_scroll.config(command=self.used_listbox.yview)

        # Context menu for used waters
        self.used_menu = tk.Menu(self.root, tearoff=0, bg=self.bg_color, fg=self.fg_color)
        self.used_menu.add_command(label="Restore to Available", command=self.restore_used_water)
        self.used_menu.add_command(label="Export Script (3 waters)", command=self.export_from_used)
        self.used_menu.add_separator()
        self.used_menu.add_command(label="Delete", command=self.delete_used_water)
        self.used_listbox.bind("<Button-3>", self.show_used_menu)
        
        # Status bar
        self.status_label = tk.Label(
            main_frame,
            text="Ready",
            font=("Arial", 9),
            bg=self.bg_color,
            fg=self.fg_color,
            anchor=tk.W,
            relief=tk.SUNKEN,
            bd=1
        )
        self.status_label.pack(fill=tk.X, pady=(5, 0))
    
    def refresh_display(self):
        """Refresh all displayed data"""
        # Available waters
        self.available_listbox.delete(0, tk.END)
        for water in self.manager.waters:
            self.available_listbox.insert(
                tk.END, 
                f"ID#{water['id']:03d}: {water['value']:8.3f}"
            )
        
        # Used waters
        self.used_listbox.delete(0, tk.END)
        for water in self.manager.used_waters:
            self.used_listbox.insert(
                tk.END,
                f"ID#{water['id']:03d}: {water['value']:8.3f}"
            )
        
        # Update status
        self.status_label.config(
            text=f"Available: {len(self.manager.waters)} | Used: {len(self.manager.used_waters)}"
        )

    def toggle_stay_on_top(self):
        """Toggle the window's always-on-top state"""
        self.root.attributes('-topmost', self.stay_on_top_var.get())

    def add_waters(self):
        """Add new waters from entry"""
        values_str = self.add_entry.get().strip()
        if not values_str:
            messagebox.showwarning("Input Required", "Please enter water values")
            return

        try:
            values = [float(v.strip()) for v in values_str.split(',')]
            self.manager.add_waters(values)
            self.add_entry.delete(0, tk.END)
            self.refresh_display()
            messagebox.showinfo(
                "Success",
                f"Added {len(values)} water(s) successfully!"
            )
        except ValueError:
            messagebox.showerror(
                "Invalid Input",
                "Please enter valid numbers separated by commas\nExample: 9.634, 9.367, 11"
            )

    def import_from_file(self):
        """Import water values from a text file"""
        # Default to UO Outlands journal logs directory
        default_dir = r"C:\Program Files (x86)\Ultima Online Outlands\ClassicUO\Data\Client\JournalLogs"
        # Fall back to current directory if journal logs path doesn't exist
        if not os.path.exists(default_dir):
            default_dir = ""

        file_path = filedialog.askopenfilename(
            title="Select Text File with Aetheric Water Values",
            initialdir=default_dir,
            filetypes=[
                ("Text files", "*.txt"),
                ("All files", "*.*")
            ]
        )

        if not file_path:
            return

        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                text = f.read()

            values = self.manager.import_from_text(text)

            if values:
                self.manager.add_waters(values)
                self.refresh_display()
                messagebox.showinfo(
                    "Import Successful",
                    f"Imported {len(values)} water value(s) from file!"
                )
            else:
                messagebox.showwarning(
                    "No Values Found",
                    "Could not find any aetheric water values in the file.\n\n"
                    "Expected format:\n"
                    "  aetheric water: 8.820 aP\n"
                    "  aetheric water: 4.540 aP"
                )
        except Exception as e:
            messagebox.showerror(
                "Import Error",
                f"Failed to import file:\n{str(e)}"
            )

    def export_scanner_script(self):
        """Export the scanner script to scan all aetheric waters in-game"""
        script_content = self.manager.generate_scanner_script()

        # Default to UO Outlands scripts directory
        default_dir = r"C:\Program Files (x86)\Ultima Online Outlands\ClassicUO\Data\Plugins\Assistant\Scripts"
        if not os.path.exists(default_dir):
            default_dir = ""

        file_path = filedialog.asksaveasfilename(
            title="Save Razor Scanner Script",
            initialdir=default_dir,
            defaultextension=".razor",
            filetypes=[
                ("Razor scripts", "*.razor"),
                ("Text files", "*.txt"),
                ("All files", "*.*")
            ],
            initialfile="aetheric_scanner.razor"
        )

        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(script_content)

                messagebox.showinfo(
                    "Scanner Script Saved",
                    f"Scanner script saved to:\n{file_path}\n\n"
                    "To use:\n"
                    "1. Load script in Razor Enhanced\n"
                    "2. Put all aetheric waters in backpack\n"
                    "3. Run script to scan values to journal\n"
                    "4. Use Import button to load values into this app"
                )
            except Exception as e:
                messagebox.showerror(
                    "Save Error",
                    f"Failed to save scanner script:\n{str(e)}"
                )

    def find_combination(self):
        """Find best combination of 3 waters"""
        try:
            target = float(self.target_entry.get())
        except ValueError:
            messagebox.showerror("Invalid Target", "Please enter a valid number for target")
            return
        
        if len(self.manager.waters) < 3:
            messagebox.showwarning(
                "Insufficient Waters",
                f"Need at least 3 available waters.\nCurrently have: {len(self.manager.waters)}"
            )
            return
        
        combo, avg = self.manager.find_best_combination(target)

        if combo is not None and avg is not None:
            self.current_combo = combo
            self.current_avg = avg

            # Display result
            self.result_text.config(state=tk.NORMAL)
            self.result_text.delete(1.0, tk.END)

            result_str = ""
            for i, water in enumerate(combo, 1):
                result_str += f"  {i}. ID#{water['id']:03d}: {water['value']:.3f}\n"

            result_str += f"\n  Average:    {avg:.6f}\n"
            result_str += f"  Difference: {abs(avg - target):.6f}\n"
            result_str += f"  Target:     {target:.6f}"

            self.result_text.insert(1.0, result_str)
            self.result_text.config(state=tk.DISABLED)

            self.use_button.config(state=tk.NORMAL)
            self.export_button.config(state=tk.NORMAL)
        else:
            messagebox.showerror("Error", "Could not find a valid combination")
    
    def export_script(self):
        """Export picker script for current combination without marking as used"""
        if self.current_combo is None:
            messagebox.showwarning("No Combination", "Please find a combination first")
            return

        script_content = self.manager.generate_picker_script(self.current_combo)

        # Default to UO Outlands scripts directory
        default_dir = r"C:\Program Files (x86)\Ultima Online Outlands\ClassicUO\Data\Plugins\Assistant\Scripts"
        if not os.path.exists(default_dir):
            default_dir = ""

        file_path = filedialog.asksaveasfilename(
            title="Save Razor Picker Script",
            initialdir=default_dir,
            defaultextension=".razor",
            filetypes=[
                ("Razor scripts", "*.razor"),
                ("Text files", "*.txt"),
                ("All files", "*.*")
            ],
            initialfile="aetheric_picker.razor"
        )

        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(script_content)

                messagebox.showinfo(
                    "Script Saved",
                    f"Picker script saved to:\n{file_path}"
                )
            except Exception as e:
                messagebox.showerror(
                    "Save Error",
                    f"Failed to save script:\n{str(e)}"
                )

    def use_combination(self):
        """Mark current combination as used"""
        if self.current_combo is None:
            messagebox.showwarning("No Combination", "Please find a combination first")
            return

        response = messagebox.askyesno(
            "Confirm Usage",
            f"Mark these 3 waters as used?\nAverage: {self.current_avg:.6f}\n\nThey will be removed from available pool."
        )

        if response:
            self.manager.use_combination(self.current_combo)
            self.current_combo = None
            self.current_avg = None
            self.use_button.config(state=tk.DISABLED)
            self.export_button.config(state=tk.DISABLED)

            self.result_text.config(state=tk.NORMAL)
            self.result_text.delete(1.0, tk.END)
            self.result_text.insert(1.0, "  Combination used! Find another combination.")
            self.result_text.config(state=tk.DISABLED)

            self.refresh_display()

    # Context menu handlers for Available Waters
    def show_available_menu(self, event):
        """Show context menu for available waters"""
        try:
            self.available_listbox.selection_clear(0, tk.END)
            self.available_listbox.selection_set(self.available_listbox.nearest(event.y))
            self.available_menu.post(event.x_root, event.y_root)
        except:
            pass

    def delete_available_water(self):
        """Delete selected water from available pool"""
        selection = self.available_listbox.curselection()
        if not selection:
            return

        idx = selection[0]
        if idx < len(self.manager.waters):
            water = self.manager.waters[idx]
            response = messagebox.askyesno(
                "Confirm Delete",
                f"Delete water ID#{water['id']:03d} ({water['value']:.3f})?\n\nThis cannot be undone."
            )
            if response:
                self.manager.delete_water(water, from_used=False)
                self.refresh_display()

    # Context menu handlers for Used Waters
    def show_used_menu(self, event):
        """Show context menu for used waters"""
        try:
            self.used_listbox.selection_clear(0, tk.END)
            self.used_listbox.selection_set(self.used_listbox.nearest(event.y))
            self.used_menu.post(event.x_root, event.y_root)
        except:
            pass

    def restore_used_water(self):
        """Restore selected water from used to available"""
        selection = self.used_listbox.curselection()
        if not selection:
            return

        idx = selection[0]
        if idx < len(self.manager.used_waters):
            water = self.manager.used_waters[idx]
            self.manager.restore_water(water)
            self.refresh_display()
            messagebox.showinfo(
                "Restored",
                f"Water ID#{water['id']:03d} ({water['value']:.3f}) restored to available pool."
            )

    def delete_used_water(self):
        """Delete selected water from used pool"""
        selection = self.used_listbox.curselection()
        if not selection:
            return

        idx = selection[0]
        if idx < len(self.manager.used_waters):
            water = self.manager.used_waters[idx]
            response = messagebox.askyesno(
                "Confirm Delete",
                f"Delete water ID#{water['id']:03d} ({water['value']:.3f})?\n\nThis cannot be undone."
            )
            if response:
                self.manager.delete_water(water, from_used=True)
                self.refresh_display()

    def export_from_used(self):
        """Export script from 3 consecutive used waters"""
        selection = self.used_listbox.curselection()
        if not selection:
            messagebox.showwarning(
                "No Selection",
                "Please select a water from the used list.\nThe script will include 3 consecutive waters starting from your selection."
            )
            return

        start_idx = selection[0]

        # Check if we have at least 3 used waters
        if len(self.manager.used_waters) < 3:
            messagebox.showwarning(
                "Insufficient Waters",
                "Need at least 3 used waters to generate a script."
            )
            return

        # Get 3 consecutive waters starting from selection
        if start_idx + 2 < len(self.manager.used_waters):
            # Can get 3 from start_idx
            combination = self.manager.used_waters[start_idx:start_idx+3]
        elif start_idx >= 2:
            # Use the last 3 waters
            combination = self.manager.used_waters[-3:]
            messagebox.showinfo(
                "Selection Adjusted",
                "Not enough waters after selection.\nUsing the last 3 used waters instead."
            )
        else:
            # Just use first 3
            combination = self.manager.used_waters[:3]
            messagebox.showinfo(
                "Selection Adjusted",
                "Using the first 3 used waters for the script."
            )

        # Generate and save script
        script_content = self.manager.generate_picker_script(combination)

        default_dir = r"C:\Program Files (x86)\Ultima Online Outlands\ClassicUO\Data\Plugins\Assistant\Scripts"
        if not os.path.exists(default_dir):
            default_dir = ""

        file_path = filedialog.asksaveasfilename(
            title="Save Razor Picker Script (from Used Waters)",
            initialdir=default_dir,
            defaultextension=".razor",
            filetypes=[
                ("Razor scripts", "*.razor"),
                ("Text files", "*.txt"),
                ("All files", "*.*")
            ],
            initialfile="aetheric_picker_used.razor"
        )

        if file_path:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(script_content)

                water_list = "\n".join([f"  ID#{w['id']:03d}: {w['value']:.3f}" for w in combination])
                messagebox.showinfo(
                    "Script Saved",
                    f"Picker script saved with these waters:\n{water_list}\n\nSaved to:\n{file_path}"
                )
            except Exception as e:
                messagebox.showerror(
                    "Save Error",
                    f"Failed to save script:\n{str(e)}"
                )


def main():
    root = tk.Tk()
    app = AethericWaterGUI(root)
    root.mainloop()


if __name__ == "__main__":
    main()